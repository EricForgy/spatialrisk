---
  output: github_document
  always_allow_html: yes
---
  
  <!-- README.md is generated from README.Rmd. Please edit that file -->
  
```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

# spatialrisk

spatialrisk is an R-package for spatial risk calculations. In particular, it can be used to determine concentration risk in the context of Solvency II. 

The package offers an effective approach to calculate the *standard formula* under Solvency II. The *standard formula* under Solvency II asks companies to report their largest fire concentration in respect of the fire peril within a radius of 200m. This is the maximum gross sum insured of the set of buildings fully or partly located within this radius. 

## Installation

Install spatialrisk from CRAN:

```{r, eval = FALSE}
install.packages("spatialrisk")
```

Or the development version from GitHub:

```{r gh-installation, eval = FALSE}
# install.packages("devtools")
devtools::install_github("MHaringa/spatialrisk")
```

```{r, include = FALSE}
library(htmltools)
library(htmlwidgets)
library(webshot)
#install_phantomjs(version = "2.1.1", baseURL = "https://github.com/wch/webshot/releases/download/v0.3.1/")
```


## Example 1
Find all observations in dataframe `Groningen` within a radius of 50m from the point *(lon,lat) = (6.561561,53.21326)*:
  
```{r example, eval = TRUE, message = FALSE, warning = FALSE}
library(spatialrisk)
points_in_circle(Groningen, lon_center = 6.571561, lat_center = 53.21326, radius = 50)
```

## Example 2
Find for each row in dataframe `df` the observations in dataframe `Groningen` within a radius of 100m from the lon/lat pair. Subsequently, the sum of the column `amount` is taken for the obtained observations.

```{r example2, eval = TRUE}
df <- data.frame(location = c("p1", "p2"), 
                 lon = c(6.561561, 6.561398), 
                 lat = c(53.21369, 53.21326))

concentration(df, Groningen, value = amount, radius = 100)

```

## Example 3
The package also contains functionality to create choropleths. Typically in R it is difficult to create choropleths. The functions presented here attempt to elegantly solve this problem.

The common approach is to first aggregate the data on the level of the regions in the shapefile and then merging the aggregated data with the shapefile. This is done by joining on the name. This approach is often problematic. For example, in case of municipality names in the Netherlands it is not easy to merge municipality names in the shapefile with the names in the data set. This is hard because of municipal reorganizations or differences in punctuation marks in municipality names. To solve this problem the data is not aggregated on the level of the regions in the shapefile. Contrary, the functions in this package detect directly the region containing the coordinates of the underlying object. This flexible approach makes it easy to create choropleth maps on different region levels.

The package has the following build-in choropleth maps:

- nl_provincie
- nl_corop
- nl_gemeente
- nl_postcode1
- nl_postcode2
- nl_postcode3
- nl_postcode4
- world_countries
- europe_countries

The insurance dataset contains 30,000 postal codes with their sum insured, population and the corresponding longitude and latitude. The following code shows how to create a simple feature object on the municipality (Dutch: *gemeente*) level. The regions are shaded by the total sum insured per region.

```{r example3, eval = TRUE}

gemeente_sf <- points_to_polygon(nl_gemeente, insurance, sum(amount, na.rm = TRUE))

```

The following code shows how to create a choropleth map based on the simple feature object obtained in the previous step. There are two options to create a choropleth map. The first approach:

```{r example3b, eval = TRUE}
choropleth(gemeente_sf, mode = "plot")
```

The second option is to create an interactive map.

```{r example3c, eval = FALSE, echo = TRUE}
choropleth(gemeente_sf, mode = "view")
```

```{r example3d, eval = TRUE, echo = FALSE}
gemeente <- choropleth(gemeente_sf, mode = "view")
tmap::tmap_leaflet(gemeente)
```

